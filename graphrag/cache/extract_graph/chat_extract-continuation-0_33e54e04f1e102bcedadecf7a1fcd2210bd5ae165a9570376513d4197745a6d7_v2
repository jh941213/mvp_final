{"result": {"id": "chatcmpl-BpSu5dC2xJx08zxohBoAm0XCsVGf7", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "(\"entity\"<|>MESSAGE_GRAPH<|>WORKFLOW<|>A workflow that defines the flow of messages between agents, created by specifying message filters to control the messages received by each agent)\n##\n(\"entity\"<|>MESSAGE_FILTERING<|>TOOL<|>A tool that allows filtering of messages received by agents, limiting their model context to relevant information)\n##\n(\"entity\"<|>ACTIVATION_GROUP<|>CONFIGURATION<|>A configuration used in cyclic workflows to handle complex dependency patterns, ensuring proper execution of nodes with multiple incoming edges)\n##\n(\"entity\"<|>ACTIVATION_CONDITION<|>CONFIGURATION<|>A configuration that specifies conditions under which a node in a cyclic workflow is activated, based on dependencies or other criteria)\n##\n(\"entity\"<|>CONDITIONAL_LOOP<|>WORKFLOW<|>A workflow pattern where agents interact in a loop, with conditions determining when the loop exits or continues)\n##\n(\"entity\"<|>USER<|>AGENT<|>An implicit agent representing the user who provides input to the workflow, such as tasks or requests)\n##\n(\"entity\"<|>APPROVE<|>EVENT<|>An event triggered by the Reviewer agent to indicate final approval of ideas or feedback, used to exit a conditional loop)\n##\n(\"entity\"<|>SUMMARIZER<|>AGENT<|>An AssistantAgent tasked with summarizing the user request and the final feedback, often used in workflows to condense information)\n##\n(\"entity\"<|>CLIMATE_CHANGE_SUMMARY<|>TASK<|>A task assigned to the Researcher agent to summarize key facts about climate change)\n##\n(\"entity\"<|>PLASTIC_WASTE_BRAINSTORM<|>TASK<|>A task assigned to the Generator agent to brainstorm ways to reduce plastic waste)\n##\n(\"entity\"<|>CREATIVE_IDEAS_GENERATION<|>TASK<|>A task assigned to the Generator agent to generate a list of creative ideas)\n##\n(\"relationship\"<|>MESSAGE_GRAPH<|>MESSAGE_FILTERING<|>The message graph is defined using the message filtering tool to control the flow of messages between agents<|>9)\n##\n(\"relationship\"<|>MESSAGE_FILTERING<|>MESSAGEFILTERAGENT<|>Message filtering is implemented by the MessageFilterAgent to control the messages received by agents<|>9)\n##\n(\"relationship\"<|>ACTIVATION_GROUP<|>ACTIVATION_CONDITION<|>Activation groups use activation conditions to determine when nodes in a cyclic workflow are executed<|>8)\n##\n(\"relationship\"<|>CONDITIONAL_LOOP<|>GENERATOR<|>The Generator agent participates in a conditional loop, generating ideas until the Reviewer approves<|>8)\n##\n(\"relationship\"<|>CONDITIONAL_LOOP<|>REVIEWER<|>The Reviewer agent participates in a conditional loop, providing feedback or approval to the Generator<|>8)\n##\n(\"relationship\"<|>APPROVE<|>CONDITIONAL_LOOP<|>The \"APPROVE\" event is used to exit the conditional loop between the Generator and Reviewer agents<|>9)\n##\n(\"relationship\"<|>USER<|>GENERATOR<|>The User provides the initial task or input to the Generator agent in workflows<|>7)\n##\n(\"relationship\"<|>USER<|>SUMMARIZER<|>The User provides the initial input that the Summarizer agent condenses into a summary<|>7)\n##\n(\"relationship\"<|>CLIMATE_CHANGE_SUMMARY<|>RESEARCHER<|>The Researcher agent is tasked with summarizing key facts about climate change<|>9)\n##\n(\"relationship\"<|>PLASTIC_WASTE_BRAINSTORM<|>GENERATOR<|>The Generator agent is tasked with brainstorming ways to reduce plastic waste<|>9)\n##\n(\"relationship\"<|>CREATIVE_IDEAS_GENERATION<|>GENERATOR<|>The Generator agent is tasked with generating a list of creative ideas<|>9)\n##\n(\"relationship\"<|>SUMMARIZER<|>FILTERED_SUMMARIZER<|>The Summarizer agent is wrapped by the Filtered_Summarizer agent to apply message filtering rules<|>9)\n##\n(\"relationship\"<|>ACTIVATION_GROUP<|>DIGRAPHBUILDER<|>Activation groups are configured in the DiGraphBuilder to handle complex dependency patterns in workflows<|>7)\n##\n(\"relationship\"<|>ACTIVATION_CONDITION<|>DIGRAPHBUILDER<|>Activation conditions are specified in the DiGraphBuilder to control node execution in workflows<|>7)\n##\n(\"relationship\"<|>APPROVE<|>REVIEWER<|>The Reviewer agent triggers the \"APPROVE\" event to indicate final approval of ideas<|>8)\n##\n(\"relationship\"<|>SUMMARIZER<|>REVIEWER<|>The Summarizer agent condenses the final feedback provided by the Reviewer agent<|>8)\n##\n(\"relationship\"<|>SUMMARIZER<|>USER<|>The Summarizer agent condenses the initial input provided by the User<|>7)\n##\n(\"relationship\"<|>MESSAGEFILTERCONFIG<|>FILTERED_ANALYST<|>The Filtered_Analyst agent uses MessageFilterConfig to apply filtering rules to its input<|>9)\n##\n(\"relationship\"<|>MESSAGEFILTERCONFIG<|>FILTERED_PRESENTER<|>The Filtered_Presenter agent uses MessageFilterConfig to apply filtering rules to its input<|>9)\n##\n(\"relationship\"<|>MESSAGEFILTERCONFIG<|>FILTERED_SUMMARIZER<|>The Filtered_Summarizer agent uses MessageFilterConfig to apply filtering rules to its input<|>9)\n##\n(\"relationship\"<|>PERSOURCEFILTER<|>MESSAGEFILTERCONFIG<|>PerSourceFilter is used within MessageFilterConfig to define specific filtering rules<|>8)\n##\n(\"relationship\"<|>DIGRAPHBUILDER<|>GRAPHFLOW<|>The DiGraphBuilder constructs the directed graph that defines the GraphFlow workflow<|>9)\n##\n(\"relationship\"<|>GRAPHFLOW<|>CONSOLE<|>The GraphFlow workflow is executed and displayed in the Console<|>7)\n##\n(\"relationship\"<|>GENERATOR<|>GRAPHFLOW<|>The Generator agent is a participant in the GraphFlow workflow<|>8)\n##\n(\"relationship\"<|>REVIEWER<|>GRAPHFLOW<|>The Reviewer agent is a participant in the GraphFlow workflow<|>8)\n##\n(\"relationship\"<|>SUMMARIZER<|>GRAPHFLOW<|>The Summarizer agent is a participant in the GraphFlow workflow<|>8)\n##\n(\"relationship\"<|>FILTERED_ANALYST<|>GRAPHFLOW<|>The Filtered_Analyst agent is a participant in the GraphFlow workflow<|>8)\n##\n(\"relationship\"<|>FILTERED_PRESENTER<|>GRAPHFLOW<|>The Filtered_Presenter agent is a participant in the GraphFlow workflow<|>8)\n##\n(\"relationship\"<|>FILTERED_SUMMARIZER<|>GRAPHFLOW<|>The Filtered_Summarizer agent is a participant in the GraphFlow workflow<|>8)\n<|COMPLETE|>", "refusal": null, "role": "assistant", "annotations": [], "audio": null, "function_call": null, "tool_calls": null}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "created": 1751605533, "model": "gpt-4o-2024-11-20", "object": "chat.completion", "service_tier": null, "system_fingerprint": "fp_ee1d74bde0", "usage": {"completion_tokens": 1548, "prompt_tokens": 5296, "total_tokens": 6844, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": 0}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 2560}}, "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}]}, "input": {"messages": [{"content": "\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"<|><entity_name><|><entity_type><|><entity_description>)\n\n2. From the entities identified in step 1, identify all pairs of (source_entity, target_entity) that are *clearly related* to each other.\nFor each pair of related entities, extract the following information:\n- source_entity: name of the source entity, as identified in step 1\n- target_entity: name of the target entity, as identified in step 1\n- relationship_description: explanation as to why you think the source entity and the target entity are related to each other\n- relationship_strength: an integer score between 1 to 10, indicating strength of the relationship between the source entity and target entity\nFormat each relationship as (\"relationship\"<|><source_entity><|><target_entity><|><relationship_description><|><relationship_strength>)\n\n3. Return output in English as a single list of all the entities and relationships identified in steps 1 and 2. Use **##** as the list delimiter.\n\n4. If you have to translate into English, just translate the descriptions, nothing else!\n\n5. When finished, output <|COMPLETE|>.\n\n-Examples-\n######################\n\nExample 1:\n\nentity_types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\ntext:\n, you will need to overload the `add`, `query` and `update_context` methods to implement the desired functionality and pass the memory store to your agent.\n\nCurrently the following example memory stores are available as part of the `autogen_ext` extensions package.\n\n- `autogen_ext.memory.chromadb.ChromaDBVectorMemory`: A memory store that uses a vector database to store and retrieve information.\n- `autogen_ext.memory.chromadb.SentenceTransformerEmbeddingFunctionConfig`: A configuration class for the SentenceTransformer embedding function used by the ChromaDBVectorMemory store. Note that other embedding functions such as `autogen_ext.memory.openai.OpenAIEmbeddingFunctionConfig` can also be used with the ChromaDBVectorMemory store.\n\n```python\nimport tempfile\n\nfrom autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.ui import Console\nfrom autogen_core.memory import MemoryContent, MemoryMimeType\nfrom autogen_ext.memory.chromadb import (\n    ChromaDBVectorMemory,\n    PersistentChromaDBVectorMemoryConfig,\n    SentenceTransformerEmbeddingFunctionConfig,\n)\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\n# Use a temporary directory for ChromaDB persistence\nwith tempfile.TemporaryDirectory() as tmpdir:\n    chroma_user_memory = ChromaDBVectorMemory(\n        config=PersistentChromaDBVectorMemoryConfig(\n            collection_name=\"preferences\",\n            persistence_path=tmpdir,  # Use the temp directory here\n            k=2,  # Return top k results\n            score_threshold=0.4,  # Minimum similarity score\n            embedding_function_config=SentenceTransformerEmbeddingFunctionConfig(\n                model_name=\"all-MiniLM-L6-v2\"  # Use default model for testing\n            ),\n        )\n    )\n    # Add user preferences to memory\n    await chroma_user_memory.add(\n        MemoryContent(\n            content=\"The weather should be in metric units\",\n            mime_type=MemoryMimeType.TEXT,\n            metadata={\"category\": \"preferences\", \"type\": \"units\"},\n        )\n    )\n\n    await chroma_user_memory.add(\n        MemoryContent(\n            content=\"Meal recipe must be vegan\",\n            mime_type=MemoryMimeType.TEXT,\n            metadata={\"category\": \"preferences\", \"type\": \"dietary\"},\n        )\n    )\n\n    model_client = OpenAIChatCompletionClient(\n        model=\"gpt-4o\",\n    )\n\n    # Create assistant agent with\n------------------------\noutput:\n(\"entity\"<|>ADD<|>TOOL<|>The `add` method is used to add content to the memory store, such as user preferences or other data)\n##\n(\"entity\"<|>QUERY<|>TOOL<|>The `query` method is used to retrieve information from the memory store based on specific criteria or similarity scores)\n##\n(\"entity\"<|>UPDATE_CONTEXT<|>TOOL<|>The `update_context` method is used to modify or update the context of the memory store to reflect new information or changes)\n##\n(\"entity\"<|>CHROMADBVECTORMEMORY<|>MEMORY_STORE<|>A memory store that uses a vector database to store and retrieve information, part of the `autogen_ext` extensions package)\n##\n(\"entity\"<|>SENTENCETRANSFORMEREMBEDDINGFUNCTIONCONFIG<|>CONFIGURATION<|>A configuration class for the SentenceTransformer embedding function used by the ChromaDBVectorMemory store, specifying the model and its parameters)\n##\n(\"entity\"<|>OPENAIEMBEDDINGFUNCTIONCONFIG<|>CONFIGURATION<|>An alternative embedding function configuration that can also be used with the ChromaDBVectorMemory store)\n##\n(\"entity\"<|>PERSISTENTCHROMADBVECTORMEMORYCONFIG<|>CONFIGURATION<|>A configuration class for persistent storage of ChromaDBVectorMemory, including parameters like collection name, persistence path, and similarity thresholds)\n##\n(\"entity\"<|>MEMORYCONTENT<|>COMPONENT<|>A component representing the content to be stored in memory, including attributes like content, MIME type, and metadata)\n##\n(\"entity\"<|>MEMORYMIMETYPE<|>COMPONENT<|>A component specifying the MIME type of the memory content, such as TEXT)\n##\n(\"entity\"<|>OPENAICHATCOMPLETIONCLIENT<|>MODEL_CLIENT<|>A model client for interacting with OpenAI's GPT-4 model, used for generating responses or performing tasks)\n##\n(\"entity\"<|>ASSISTANTAGENT<|>AGENT<|>An agent created to assist with tasks, leveraging memory stores and model clients for enhanced functionality)\n##\n(\"entity\"<|>TEMPFILE<|>COMPONENT<|>A component used to create temporary directories for storing persistent memory data during runtime)\n##\n(\"relationship\"<|>CHROMADBVECTORMEMORY<|>SENTENCETRANSFORMEREMBEDDINGFUNCTIONCONFIG<|>The ChromaDBVectorMemory store uses the SentenceTransformerEmbeddingFunctionConfig for embedding functions<|>8)\n##\n(\"relationship\"<|>CHROMADBVECTORMEMORY<|>PERSISTENTCHROMADBVECTORMEMORYCONFIG<|>The ChromaDBVectorMemory store is configured for persistence using PersistentChromaDBVectorMemoryConfig<|>9)\n##\n(\"relationship\"<|>CHROMADBVECTORMEMORY<|>MEMORYCONTENT<|>The ChromaDBVectorMemory store stores MemoryContent, which includes user preferences and other data<|>8)\n##\n(\"relationship\"<|>MEMORYCONTENT<|>MEMORYMIMETYPE<|>MemoryContent specifies its MIME type using MemoryMimeType, such as TEXT<|>7)\n##\n(\"relationship\"<|>ASSISTANTAGENT<|>CHROMADBVECTORMEMORY<|>The AssistantAgent uses the ChromaDBVectorMemory store to manage and retrieve memory<|>9)\n##\n(\"relationship\"<|>ASSISTANTAGENT<|>OPENAICHATCOMPLETIONCLIENT<|>The AssistantAgent uses the OpenAIChatCompletionClient for generating responses and performing tasks<|>9)\n##\n(\"relationship\"<|>TEMPFILE<|>PERSISTENTCHROMADBVECTORMEMORYCONFIG<|>Tempfile is used to create a temporary directory for the persistence path in PersistentChromaDBVectorMemoryConfig<|>6)\n##\n(\"relationship\"<|>ADD<|>CHROMADBVECTORMEMORY<|>The `add` method is used to add data to the ChromaDBVectorMemory store<|>8)\n##\n(\"relationship\"<|>QUERY<|>CHROMADBVECTORMEMORY<|>The `query` method is used to retrieve data from the ChromaDBVectorMemory store<|>8)\n##\n(\"relationship\"<|>UPDATE_CONTEXT<|>CHROMADBVECTORMEMORY<|>The `update_context` method is used to modify the context of the ChromaDBVectorMemory store<|>7)\n<|COMPLETE|>\n#############################\n\n\nExample 2:\n\nentity_types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\ntext:\n on actions *within* the agent itself, and belong to subclasses of the base class `BaseAgentEvent`.\n\nExamples of these include `ToolCallRequestEvent`, which indicates that a request was made to call a tool, and `ToolCallExecutionEvent`, which contains the results of tool calls.\n\nTypically, events are created by the agent itself and are contained in the `inner_messages` field of the `Response` returned from `on_messages`. If you are building a custom agent and have events that you want to communicate to other entities (e.g., a UI), you can include these in the `inner_messages` field of the `Response`. We will show examples of this in Custom Agents.\n\nYou can read about the full set of messages supported in AgentChat in the `messages` module.\n\n## Custom Message Types\n\nYou can create custom message types by subclassing the base class `BaseChatMessage` or `BaseAgentEvent`. This allows you to define your own message formats and behaviors, tailored to your application. Custom message types are useful when you write custom agents.\n\n------------------------\noutput:\n(\"entity\"<|>BASEAGENTEVENT<|>event<|>Base class for events within the agent itself, used to define specific types of agent-related events)\n##\n(\"entity\"<|>TOOLCALLREQUESTEVENT<|>event<|>An event indicating that a request was made to call a tool)\n##\n(\"entity\"<|>TOOLCALLEXECUTIONEVENT<|>event<|>An event containing the results of tool calls)\n##\n(\"entity\"<|>INNER_MESSAGES<|>message<|>Field in the `Response` object that contains events created by the agent itself, such as tool call events)\n##\n(\"entity\"<|>RESPONSE<|>message<|>Object returned from `on_messages` that contains fields like `inner_messages` to communicate events)\n##\n(\"entity\"<|>BASECHATMESSAGE<|>message<|>Base class for creating custom message types tailored to specific applications)\n##\n(\"entity\"<|>AGENTCHAT<|>component<|>Module that supports a full set of messages for agent communication)\n##\n(\"entity\"<|>CUSTOM AGENTS<|>agent<|>Agents that are built with custom events and message types to communicate with other entities, such as UIs)\n##\n(\"relationship\"<|>TOOLCALLREQUESTEVENT<|>BASEAGENTEVENT<|>ToolCallRequestEvent is a subclass of BaseAgentEvent, representing a specific type of event<|>8)\n##\n(\"relationship\"<|>TOOLCALLEXECUTIONEVENT<|>BASEAGENTEVENT<|>ToolCallExecutionEvent is a subclass of BaseAgentEvent, representing a specific type of event<|>8)\n##\n(\"relationship\"<|>INNER_MESSAGES<|>RESPONSE<|>Inner_messages is a field in the Response object that contains events created by the agent<|>9)\n##\n(\"relationship\"<|>CUSTOM AGENTS<|>INNER_MESSAGES<|>Custom agents can include events in the inner_messages field to communicate with other entities<|>7)\n##\n(\"relationship\"<|>BASECHATMESSAGE<|>CUSTOM AGENTS<|>Custom agents can use BaseChatMessage to define their own message formats and behaviors<|>8)\n##\n(\"relationship\"<|>AGENTCHAT<|>RESPONSE<|>AgentChat supports the full set of messages, including those contained in the Response object<|>6)\n<|COMPLETE|>\n#############################\n\n\n\n-Real Data-\n######################\nentity_types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\ntext: the order in which agents execute. However, the execution graph does not control what messages an agent receives from other agents. By default, all messages are sent to all agents in the graph.\n\nMessage filtering is a separate feature that allows you to filter the messages received by each agent and limiting their model context to only the relevant information. The set of message filters defines the message graph in the flow.\n\nSpecifying the message graph can help with:\n\n- Reduce hallucinations\n- Control memory load\n- Focus agents only on relevant information\n\nYou can use `MessageFilterAgent` together with `MessageFilterConfig` and `PerSourceFilter` to define these rules.\n\n```python\nfrom autogen_agentchat.agents import AssistantAgent, MessageFilterAgent, MessageFilterConfig, PerSourceFilter\nfrom autogen_agentchat.teams import DiGraphBuilder, GraphFlow\nfrom autogen_agentchat.ui import Console\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\n# Model client\nclient = OpenAIChatCompletionClient(model=\"gpt-4.1-nano\")\n\n# Create agents\nresearcher = AssistantAgent(\n    \"researcher\", model_client=client, system_message=\"Summarize key facts about climate change.\"\n)\nanalyst = AssistantAgent(\"analyst\", model_client=client, system_message=\"Review the summary and suggest improvements.\")\npresenter = AssistantAgent(\n    \"presenter\", model_client=client, system_message=\"Prepare a presentation slide based on the final summary.\"\n)\n\n# Apply message filtering\nfiltered_analyst = MessageFilterAgent(\n    name=\"analyst\",\n    wrapped_agent=analyst,\n    filter=MessageFilterConfig(per_source=[PerSourceFilter(source=\"researcher\", position=\"last\", count=1)]),\n)\n\nfiltered_presenter = MessageFilterAgent(\n    name=\"presenter\",\n    wrapped_agent=presenter,\n    filter=MessageFilterConfig(per_source=[PerSourceFilter(source=\"analyst\", position=\"last\", count=1)]),\n)\n\n# Build the flow\nbuilder = DiGraphBuilder()\nbuilder.add_node(researcher).add_node(filtered_analyst).add_node(filtered_presenter)\nbuilder.add_edge(researcher, filtered_analyst).add_edge(filtered_analyst, filtered_presenter)\n\n# Create the flow\nflow = GraphFlow(\n    participants=builder.get_participants(),\n    graph=builder.build(),\n)\n\n# Run the flow\nawait Console(flow.run_stream(task=\"Summarize key facts about climate change.\"))\n```\n\n## 🔁 Advanced Example: Conditional Loop + Filtered Summary\n\nThis example demonstrates:\n\n- A loop between generator and reviewer (which exits when reviewer says \"APPROVE\")\n- A summarizer agent that only sees the first user input and the last reviewer message\n\n```python\nfrom autogen_agentchat.agents import AssistantAgent, MessageFilterAgent, MessageFilterConfig, PerSourceFilter\nfrom autogen_agentchat.teams import (\n    DiGraphBuilder,\n    GraphFlow,\n)\nfrom autogen_agentchat.ui import Console\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\nmodel_client = OpenAIChatCompletionClient(model=\"gpt-4o-mini\")\n\n# Agents\ngenerator = AssistantAgent(\"generator\", model_client=model_client, system_message=\"Generate a list of creative ideas.\")\nreviewer = AssistantAgent(\n    \"reviewer\",\n    model_client=model_client,\n    system_message=\"Review ideas and provide feedbacks, or just 'APPROVE' for final approval.\",\n)\nsummarizer_core = AssistantAgent(\n    \"summary\", model_client=model_client, system_message=\"Summarize the user request and the final feedback.\"\n)\n\n# Filtered summarizer\nfiltered_summarizer = MessageFilterAgent(\n    name=\"summary\",\n    wrapped_agent=summarizer_core,\n    filter=MessageFilterConfig(\n        per_source=[\n            PerSourceFilter(source=\"user\", position=\"first\", count=1),\n            PerSourceFilter(source=\"reviewer\", position=\"last\", count=1),\n        ]\n    ),\n)\n\n# Build graph with conditional loop\nbuilder = DiGraphBuilder()\nbuilder.add_node(generator).add_node(reviewer).add_node(filtered_summarizer)\nbuilder.add_edge(generator, reviewer)\nbuilder.add_edge(reviewer, filtered_summarizer, condition=lambda msg: \"APPROVE\" in msg.to_model_text())\nbuilder.add_edge(reviewer, generator, condition=lambda msg: \"APPROVE\" not in msg.to_model_text())\nbuilder.set_entry_point(generator)  # Set entry point to generator. Required if there are no source nodes.\ngraph = builder.build()\n\n# Create the flow\nflow = GraphFlow(\n    participants=builder.get_participants(),\n    graph=graph,\n)\n\n# Run the flow and pretty print the output in the console\nawait Console(flow.run_stream(task=\"Brainstorm ways to reduce plastic waste.\"))\n```\n\n## 🔁 Advanced Example: Cycles With Activation Group Examples\n\nThe following examples demonstrate how to use `activation_group` and `activation_condition` to handle complex dependency patterns in cyclic graphs, especially when multiple paths lead to the same target node.\n\n### Example 1: Loop with Multiple Paths - \"All\" Activation (A→B→C→B)\n\nIn this scenario, we have A → B → C → B, where B has two incoming edges (from A and from C). By default, B requires all its dependencies to be satisfied before executing.\n\nThis example shows a review loop where both the initial input (A) and the feedback (C) must be processed before B can execute again.\n\n```python\nfrom autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.teams import DiGraphBuilder, GraphFlow\nfrom autogen_agentchat.ui import Console\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\n# Model client\nclient = OpenAIChatCompletionClient(model=\"gpt-\n######################\noutput:", "role": "user"}, {"role": "assistant", "content": "(\"entity\"<|>ASSISTANTAGENT<|>AGENT<|>An agent that performs tasks based on a system message and interacts with other agents or components in the workflow)\n##\n(\"entity\"<|>MESSAGEFILTERAGENT<|>AGENT<|>An agent that wraps another agent and applies message filtering rules to control the messages it receives)\n##\n(\"entity\"<|>MESSAGEFILTERCONFIG<|>CONFIGURATION<|>A configuration class used to define message filtering rules, such as per-source filters)\n##\n(\"entity\"<|>PERSOURCEFILTER<|>CONFIGURATION<|>A configuration specifying filtering rules for messages from a specific source, including position and count)\n##\n(\"entity\"<|>DIGRAPHBUILDER<|>COMPONENT<|>A component used to build directed graphs for defining workflows and agent interactions)\n##\n(\"entity\"<|>GRAPHFLOW<|>WORKFLOW<|>A workflow that defines the flow of messages and interactions between agents in a directed graph)\n##\n(\"entity\"<|>CONSOLE<|>COMPONENT<|>A component used to run and display the output of workflows in a console interface)\n##\n(\"entity\"<|>OPENAICHATCOMPLETIONCLIENT<|>MODEL_CLIENT<|>A model client for interacting with OpenAI's GPT models, used for generating responses or performing tasks)\n##\n(\"entity\"<|>RESEARCHER<|>AGENT<|>An AssistantAgent tasked with summarizing key facts about climate change)\n##\n(\"entity\"<|>ANALYST<|>AGENT<|>An AssistantAgent tasked with reviewing summaries and suggesting improvements)\n##\n(\"entity\"<|>PRESENTER<|>AGENT<|>An AssistantAgent tasked with preparing presentation slides based on final summaries)\n##\n(\"entity\"<|>FILTERED_ANALYST<|>AGENT<|>A MessageFilterAgent wrapping the Analyst agent, applying message filtering rules to control its input)\n##\n(\"entity\"<|>FILTERED_PRESENTER<|>AGENT<|>A MessageFilterAgent wrapping the Presenter agent, applying message filtering rules to control its input)\n##\n(\"entity\"<|>GENERATOR<|>AGENT<|>An AssistantAgent tasked with generating creative ideas)\n##\n(\"entity\"<|>REVIEWER<|>AGENT<|>An AssistantAgent tasked with reviewing ideas and providing feedback or final approval)\n##\n(\"entity\"<|>SUMMARIZER_CORE<|>AGENT<|>An AssistantAgent tasked with summarizing user requests and final feedback)\n##\n(\"entity\"<|>FILTERED_SUMMARIZER<|>AGENT<|>A MessageFilterAgent wrapping the Summarizer_Core agent, applying message filtering rules to control its input)\n##\n(\"relationship\"<|>MESSAGEFILTERAGENT<|>MESSAGEFILTERCONFIG<|>MessageFilterAgent uses MessageFilterConfig to define the filtering rules for messages<|>9)\n##\n(\"relationship\"<|>MESSAGEFILTERCONFIG<|>PERSOURCEFILTER<|>MessageFilterConfig uses PerSourceFilter to specify filtering rules for messages from specific sources<|>8)\n##\n(\"relationship\"<|>DIGRAPHBUILDER<|>GRAPHFLOW<|>DiGraphBuilder is used to construct the directed graph that defines the GraphFlow workflow<|>9)\n##\n(\"relationship\"<|>CONSOLE<|>GRAPHFLOW<|>Console is used to run and display the output of the GraphFlow workflow<|>7)\n##\n(\"relationship\"<|>ASSISTANTAGENT<|>OPENAICHATCOMPLETIONCLIENT<|>AssistantAgent uses OpenAIChatCompletionClient to interact with GPT models for generating responses<|>9)\n##\n(\"relationship\"<|>RESEARCHER<|>ANALYST<|>The Researcher agent sends its summary to the Analyst agent for review and suggestions<|>8)\n##\n(\"relationship\"<|>ANALYST<|>PRESENTER<|>The Analyst agent sends its reviewed summary to the Presenter agent for preparing presentation slides<|>8)\n##\n(\"relationship\"<|>FILTERED_ANALYST<|>ANALYST<|>Filtered_Analyst wraps the Analyst agent and applies message filtering rules to control its input<|>9)\n##\n(\"relationship\"<|>FILTERED_PRESENTER<|>PRESENTER<|>Filtered_Presenter wraps the Presenter agent and applies message filtering rules to control its input<|>9)\n##\n(\"relationship\"<|>GENERATOR<|>REVIEWER<|>The Generator agent sends its generated ideas to the Reviewer agent for feedback or approval<|>8)\n##\n(\"relationship\"<|>REVIEWER<|>FILTERED_SUMMARIZER<|>The Reviewer agent sends its final feedback to the Filtered_Summarizer agent for summarization<|>8)\n##\n(\"relationship\"<|>FILTERED_SUMMARIZER<|>SUMMARIZER_CORE<|>Filtered_Summarizer wraps the Summarizer_Core agent and applies message filtering rules to control its input<|>9)\n##\n(\"relationship\"<|>DIGRAPHBUILDER<|>CONSOLE<|>DiGraphBuilder constructs the graph that is executed and displayed in the Console<|>7)\n##\n(\"relationship\"<|>GENERATOR<|>REVIEWER<|>The Generator agent loops back to the Reviewer agent until the Reviewer approves the ideas<|>8)\n##\n(\"relationship\"<|>REVIEWER<|>GENERATOR<|>The Reviewer agent sends feedback to the Generator agent for further idea generation if not approved<|>8)\n##\n(\"relationship\"<|>REVIEWER<|>FILTERED_SUMMARIZER<|>The Reviewer agent sends its final feedback to the Filtered_Summarizer agent for summarization<|>8)\n##\n(\"relationship\"<|>RESEARCHER<|>FILTERED_ANALYST<|>The Researcher agent sends its summary to the Filtered_Analyst agent for review and suggestions<|>8)\n##\n(\"relationship\"<|>FILTERED_ANALYST<|>FILTERED_PRESENTER<|>The Filtered_Analyst agent sends its reviewed summary to the Filtered_Presenter agent for preparing presentation slides<|>8)\n<|COMPLETE|>"}, {"content": "MANY entities and relationships were missed in the last extraction. Remember to ONLY emit entities that match any of the previously extracted types. Add them below using the same format:\n", "role": "user"}], "parameters": {"model": "gpt-4o", "frequency_penalty": 0.0, "max_tokens": null, "n": 1, "presence_penalty": 0.0, "temperature": 0.0, "top_p": 1.0}}, "key": "chat_extract-continuation-0_33e54e04f1e102bcedadecf7a1fcd2210bd5ae165a9570376513d4197745a6d7_v2"}