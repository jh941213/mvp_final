{"result": {"id": "chatcmpl-BpSeAxEXTjikOxVhzpMkdjRcxXhGP", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "(\"entity\"<|>SELECTOR_FUNC<|>TOOL<|>A custom selector function used to override the default model-based selection process, allowing for more complex selection logic and state-based transitions)\n##\n(\"entity\"<|>PLANNING_AGENT<|>AGENT<|>An agent responsible for planning tasks and checking progress, often interacting with specialized agents)\n##\n(\"entity\"<|>WEB_SEARCH_AGENT<|>AGENT<|>A specialized agent tasked with performing web searches as part of a team workflow)\n##\n(\"entity\"<|>DATA_ANALYST_AGENT<|>AGENT<|>A specialized agent responsible for analyzing data and providing insights as part of a team workflow)\n##\n(\"entity\"<|>SELECTORGROUPCHAT<|>WORKFLOW<|>A team-based workflow that coordinates multiple agents, using custom selector and candidate functions for speaker selection)\n##\n(\"entity\"<|>TERMINATION<|>TERMINATION_CONDITION<|>A condition that determines when the SelectorGroupChat workflow should end)\n##\n(\"entity\"<|>SELECTOR_PROMPT<|>CONTEXT<|>A prompt used to guide the selector function in determining the next speaker in the SelectorGroupChat workflow)\n##\n(\"entity\"<|>CANDIDATE_FUNC<|>TOOL<|>A custom candidate function used to filter the list of potential agents for speaker selection in each turn of the group chat)\n##\n(\"entity\"<|>USERPROXYAGENT<|>AGENT<|>An agent that acts as a proxy for the user, providing feedback such as approval or disapproval of tasks during a run)\n##\n(\"entity\"<|>TOOLCALLSUMMARYMESSAGE<|>MESSAGE<|>A message type indicating the summary of tool calls made by an agent, used to determine if an agent has completed its tasks)\n##\n(\"entity\"<|>CONSOLE<|>COMPONENT<|>A component used to run and display the output of the SelectorGroupChat workflow in a streaming format)\n##\n(\"entity\"<|>TASK<|>TASK<|>A specific objective or set of actions assigned to agents within the SelectorGroupChat workflow)\n##\n(\"relationship\"<|>SELECTOR_FUNC<|>PLANNING_AGENT<|>The selector function ensures that the Planning Agent speaks immediately after specialized agents to check progress<|>9)\n##\n(\"relationship\"<|>PLANNING_AGENT<|>WEB_SEARCH_AGENT<|>The Planning Agent interacts with the Web Search Agent to assign tasks and retrieve results<|>8)\n##\n(\"relationship\"<|>PLANNING_AGENT<|>DATA_ANALYST_AGENT<|>The Planning Agent interacts with the Data Analyst Agent to assign tasks and retrieve insights<|>8)\n##\n(\"relationship\"<|>SELECTORGROUPCHAT<|>PLANNING_AGENT<|>The Planning Agent is a participant in the SelectorGroupChat workflow<|>9)\n##\n(\"relationship\"<|>SELECTORGROUPCHAT<|>WEB_SEARCH_AGENT<|>The Web Search Agent is a participant in the SelectorGroupChat workflow<|>9)\n##\n(\"relationship\"<|>SELECTORGROUPCHAT<|>DATA_ANALYST_AGENT<|>The Data Analyst Agent is a participant in the SelectorGroupChat workflow<|>9)\n##\n(\"relationship\"<|>SELECTORGROUPCHAT<|>TERMINATION<|>The SelectorGroupChat workflow ends when the termination condition is met<|>8)\n##\n(\"relationship\"<|>SELECTORGROUPCHAT<|>SELECTOR_PROMPT<|>The SelectorGroupChat workflow uses the selector prompt to guide the selector function<|>7)\n##\n(\"relationship\"<|>SELECTOR_FUNC<|>CANDIDATE_FUNC<|>The selector function and candidate function are mutually exclusive tools for determining the next speaker in the workflow<|>6)\n##\n(\"relationship\"<|>USERPROXYAGENT<|>PLANNING_AGENT<|>The UserProxyAgent provides feedback to the Planning Agent, influencing task approval and continuation<|>8)\n##\n(\"relationship\"<|>TOOLCALLSUMMARYMESSAGE<|>PLANNING_AGENT<|>The Planning Agent uses ToolCallSummaryMessage to determine if it has completed all necessary tool calls<|>7)\n##\n(\"relationship\"<|>CONSOLE<|>SELECTORGROUPCHAT<|>The Console component is used to run and display the SelectorGroupChat workflow<|>6)\n##\n(\"relationship\"<|>TASK<|>PLANNING_AGENT<|>The Planning Agent is responsible for managing and executing tasks within the workflow<|>8)\n##\n(\"relationship\"<|>TASK<|>WEB_SEARCH_AGENT<|>The Web Search Agent performs tasks related to web searches as part of the workflow<|>8)\n##\n(\"relationship\"<|>TASK<|>DATA_ANALYST_AGENT<|>The Data Analyst Agent performs tasks related to data analysis as part of the workflow<|>8)\n<|COMPLETE|>", "refusal": null, "role": "assistant", "annotations": [], "audio": null, "function_call": null, "tool_calls": null}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "protected_material_code": {"filtered": false, "detected": false}, "protected_material_text": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "created": 1751604546, "model": "gpt-4o-2024-11-20", "object": "chat.completion", "service_tier": null, "system_fingerprint": "fp_ee1d74bde0", "usage": {"completion_tokens": 1033, "prompt_tokens": 3943, "total_tokens": 4976, "completion_tokens_details": {"accepted_prediction_tokens": 0, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": 0}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 2560}}, "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "jailbreak": {"filtered": false, "detected": false}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}]}, "input": {"messages": [{"content": "\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"<|><entity_name><|><entity_type><|><entity_description>)\n\n2. From the entities identified in step 1, identify all pairs of (source_entity, target_entity) that are *clearly related* to each other.\nFor each pair of related entities, extract the following information:\n- source_entity: name of the source entity, as identified in step 1\n- target_entity: name of the target entity, as identified in step 1\n- relationship_description: explanation as to why you think the source entity and the target entity are related to each other\n- relationship_strength: an integer score between 1 to 10, indicating strength of the relationship between the source entity and target entity\nFormat each relationship as (\"relationship\"<|><source_entity><|><target_entity><|><relationship_description><|><relationship_strength>)\n\n3. Return output in English as a single list of all the entities and relationships identified in steps 1 and 2. Use **##** as the list delimiter.\n\n4. If you have to translate into English, just translate the descriptions, nothing else!\n\n5. When finished, output <|COMPLETE|>.\n\n-Examples-\n######################\n\nExample 1:\n\nentity_types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\ntext:\n, you will need to overload the `add`, `query` and `update_context` methods to implement the desired functionality and pass the memory store to your agent.\n\nCurrently the following example memory stores are available as part of the `autogen_ext` extensions package.\n\n- `autogen_ext.memory.chromadb.ChromaDBVectorMemory`: A memory store that uses a vector database to store and retrieve information.\n- `autogen_ext.memory.chromadb.SentenceTransformerEmbeddingFunctionConfig`: A configuration class for the SentenceTransformer embedding function used by the ChromaDBVectorMemory store. Note that other embedding functions such as `autogen_ext.memory.openai.OpenAIEmbeddingFunctionConfig` can also be used with the ChromaDBVectorMemory store.\n\n```python\nimport tempfile\n\nfrom autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.ui import Console\nfrom autogen_core.memory import MemoryContent, MemoryMimeType\nfrom autogen_ext.memory.chromadb import (\n    ChromaDBVectorMemory,\n    PersistentChromaDBVectorMemoryConfig,\n    SentenceTransformerEmbeddingFunctionConfig,\n)\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\n# Use a temporary directory for ChromaDB persistence\nwith tempfile.TemporaryDirectory() as tmpdir:\n    chroma_user_memory = ChromaDBVectorMemory(\n        config=PersistentChromaDBVectorMemoryConfig(\n            collection_name=\"preferences\",\n            persistence_path=tmpdir,  # Use the temp directory here\n            k=2,  # Return top k results\n            score_threshold=0.4,  # Minimum similarity score\n            embedding_function_config=SentenceTransformerEmbeddingFunctionConfig(\n                model_name=\"all-MiniLM-L6-v2\"  # Use default model for testing\n            ),\n        )\n    )\n    # Add user preferences to memory\n    await chroma_user_memory.add(\n        MemoryContent(\n            content=\"The weather should be in metric units\",\n            mime_type=MemoryMimeType.TEXT,\n            metadata={\"category\": \"preferences\", \"type\": \"units\"},\n        )\n    )\n\n    await chroma_user_memory.add(\n        MemoryContent(\n            content=\"Meal recipe must be vegan\",\n            mime_type=MemoryMimeType.TEXT,\n            metadata={\"category\": \"preferences\", \"type\": \"dietary\"},\n        )\n    )\n\n    model_client = OpenAIChatCompletionClient(\n        model=\"gpt-4o\",\n    )\n\n    # Create assistant agent with\n------------------------\noutput:\n(\"entity\"<|>ADD<|>TOOL<|>The `add` method is used to add content to the memory store, such as user preferences or other data)\n##\n(\"entity\"<|>QUERY<|>TOOL<|>The `query` method is used to retrieve information from the memory store based on specific criteria or similarity scores)\n##\n(\"entity\"<|>UPDATE_CONTEXT<|>TOOL<|>The `update_context` method is used to modify or update the context of the memory store to reflect new information or changes)\n##\n(\"entity\"<|>CHROMADBVECTORMEMORY<|>MEMORY_STORE<|>A memory store that uses a vector database to store and retrieve information, part of the `autogen_ext` extensions package)\n##\n(\"entity\"<|>SENTENCETRANSFORMEREMBEDDINGFUNCTIONCONFIG<|>CONFIGURATION<|>A configuration class for the SentenceTransformer embedding function used by the ChromaDBVectorMemory store, specifying the model and its parameters)\n##\n(\"entity\"<|>OPENAIEMBEDDINGFUNCTIONCONFIG<|>CONFIGURATION<|>An alternative embedding function configuration that can also be used with the ChromaDBVectorMemory store)\n##\n(\"entity\"<|>PERSISTENTCHROMADBVECTORMEMORYCONFIG<|>CONFIGURATION<|>A configuration class for persistent storage of ChromaDBVectorMemory, including parameters like collection name, persistence path, and similarity thresholds)\n##\n(\"entity\"<|>MEMORYCONTENT<|>COMPONENT<|>A component representing the content to be stored in memory, including attributes like content, MIME type, and metadata)\n##\n(\"entity\"<|>MEMORYMIMETYPE<|>COMPONENT<|>A component specifying the MIME type of the memory content, such as TEXT)\n##\n(\"entity\"<|>OPENAICHATCOMPLETIONCLIENT<|>MODEL_CLIENT<|>A model client for interacting with OpenAI's GPT-4 model, used for generating responses or performing tasks)\n##\n(\"entity\"<|>ASSISTANTAGENT<|>AGENT<|>An agent created to assist with tasks, leveraging memory stores and model clients for enhanced functionality)\n##\n(\"entity\"<|>TEMPFILE<|>COMPONENT<|>A component used to create temporary directories for storing persistent memory data during runtime)\n##\n(\"relationship\"<|>CHROMADBVECTORMEMORY<|>SENTENCETRANSFORMEREMBEDDINGFUNCTIONCONFIG<|>The ChromaDBVectorMemory store uses the SentenceTransformerEmbeddingFunctionConfig for embedding functions<|>8)\n##\n(\"relationship\"<|>CHROMADBVECTORMEMORY<|>PERSISTENTCHROMADBVECTORMEMORYCONFIG<|>The ChromaDBVectorMemory store is configured for persistence using PersistentChromaDBVectorMemoryConfig<|>9)\n##\n(\"relationship\"<|>CHROMADBVECTORMEMORY<|>MEMORYCONTENT<|>The ChromaDBVectorMemory store stores MemoryContent, which includes user preferences and other data<|>8)\n##\n(\"relationship\"<|>MEMORYCONTENT<|>MEMORYMIMETYPE<|>MemoryContent specifies its MIME type using MemoryMimeType, such as TEXT<|>7)\n##\n(\"relationship\"<|>ASSISTANTAGENT<|>CHROMADBVECTORMEMORY<|>The AssistantAgent uses the ChromaDBVectorMemory store to manage and retrieve memory<|>9)\n##\n(\"relationship\"<|>ASSISTANTAGENT<|>OPENAICHATCOMPLETIONCLIENT<|>The AssistantAgent uses the OpenAIChatCompletionClient for generating responses and performing tasks<|>9)\n##\n(\"relationship\"<|>TEMPFILE<|>PERSISTENTCHROMADBVECTORMEMORYCONFIG<|>Tempfile is used to create a temporary directory for the persistence path in PersistentChromaDBVectorMemoryConfig<|>6)\n##\n(\"relationship\"<|>ADD<|>CHROMADBVECTORMEMORY<|>The `add` method is used to add data to the ChromaDBVectorMemory store<|>8)\n##\n(\"relationship\"<|>QUERY<|>CHROMADBVECTORMEMORY<|>The `query` method is used to retrieve data from the ChromaDBVectorMemory store<|>8)\n##\n(\"relationship\"<|>UPDATE_CONTEXT<|>CHROMADBVECTORMEMORY<|>The `update_context` method is used to modify the context of the ChromaDBVectorMemory store<|>7)\n<|COMPLETE|>\n#############################\n\n\nExample 2:\n\nentity_types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\ntext:\n on actions *within* the agent itself, and belong to subclasses of the base class `BaseAgentEvent`.\n\nExamples of these include `ToolCallRequestEvent`, which indicates that a request was made to call a tool, and `ToolCallExecutionEvent`, which contains the results of tool calls.\n\nTypically, events are created by the agent itself and are contained in the `inner_messages` field of the `Response` returned from `on_messages`. If you are building a custom agent and have events that you want to communicate to other entities (e.g., a UI), you can include these in the `inner_messages` field of the `Response`. We will show examples of this in Custom Agents.\n\nYou can read about the full set of messages supported in AgentChat in the `messages` module.\n\n## Custom Message Types\n\nYou can create custom message types by subclassing the base class `BaseChatMessage` or `BaseAgentEvent`. This allows you to define your own message formats and behaviors, tailored to your application. Custom message types are useful when you write custom agents.\n\n------------------------\noutput:\n(\"entity\"<|>BASEAGENTEVENT<|>event<|>Base class for events within the agent itself, used to define specific types of agent-related events)\n##\n(\"entity\"<|>TOOLCALLREQUESTEVENT<|>event<|>An event indicating that a request was made to call a tool)\n##\n(\"entity\"<|>TOOLCALLEXECUTIONEVENT<|>event<|>An event containing the results of tool calls)\n##\n(\"entity\"<|>INNER_MESSAGES<|>message<|>Field in the `Response` object that contains events created by the agent itself, such as tool call events)\n##\n(\"entity\"<|>RESPONSE<|>message<|>Object returned from `on_messages` that contains fields like `inner_messages` to communicate events)\n##\n(\"entity\"<|>BASECHATMESSAGE<|>message<|>Base class for creating custom message types tailored to specific applications)\n##\n(\"entity\"<|>AGENTCHAT<|>component<|>Module that supports a full set of messages for agent communication)\n##\n(\"entity\"<|>CUSTOM AGENTS<|>agent<|>Agents that are built with custom events and message types to communicate with other entities, such as UIs)\n##\n(\"relationship\"<|>TOOLCALLREQUESTEVENT<|>BASEAGENTEVENT<|>ToolCallRequestEvent is a subclass of BaseAgentEvent, representing a specific type of event<|>8)\n##\n(\"relationship\"<|>TOOLCALLEXECUTIONEVENT<|>BASEAGENTEVENT<|>ToolCallExecutionEvent is a subclass of BaseAgentEvent, representing a specific type of event<|>8)\n##\n(\"relationship\"<|>INNER_MESSAGES<|>RESPONSE<|>Inner_messages is a field in the Response object that contains events created by the agent<|>9)\n##\n(\"relationship\"<|>CUSTOM AGENTS<|>INNER_MESSAGES<|>Custom agents can include events in the inner_messages field to communicate with other entities<|>7)\n##\n(\"relationship\"<|>BASECHATMESSAGE<|>CUSTOM AGENTS<|>Custom agents can use BaseChatMessage to define their own message formats and behaviors<|>8)\n##\n(\"relationship\"<|>AGENTCHAT<|>RESPONSE<|>AgentChat supports the full set of messages, including those contained in the Response object<|>6)\n<|COMPLETE|>\n#############################\n\n\n\n-Real Data-\n######################\nentity_types: [agent, memory_store, embedding_function, configuration, component, tool, message, event, termination_condition, subscription, task, model_client, reasoning_model, context, workflow]\ntext: the 2007-2008 and 2008-2009 seasons is 85.98%!\n\n## Custom Selector Function\n\nOften times we want better control over the selection process. To this end, we can set the `selector_func` argument with a custom selector function to override the default model-based selection. This allows us to implement more complex selection logic and state-based transitions.\n\nFor instance, we want the Planning Agent to speak immediately after any specialized agent to check the progress.\n\n> **Note**: Returning `None` from the custom selector function will use the default model-based selection.\n\n> **Note**: Custom selector functions are not serialized when `.dump_component()` is called on the `SelectorGroupChat` team. If you need to serialize team configurations with custom selector functions, consider implementing custom workflows and serialization logic.\n\n```python\ndef selector_func(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> str | None:\n    if messages[-1].source != planning_agent.name:\n        return planning_agent.name\n    return None\n\n\n# Reset the previous team and run the chat again with the selector function.\nawait team.reset()\nteam = SelectorGroupChat(\n    [planning_agent, web_search_agent, data_analyst_agent],\n    model_client=model_client,\n    termination_condition=termination,\n    selector_prompt=selector_prompt,\n    allow_repeated_speaker=True,\n    selector_func=selector_func,\n)\n\nawait Console(team.run_stream(task=task))\n```\n\nYou can see from the conversation log that the Planning Agent always speaks immediately after the specialized agents.\n\n> **Tip**: Each participant agent only makes one step (executing tools, generating a response, etc.) on each turn. If you want an `AssistantAgent` to repeat until it stop returning a `ToolCallSummaryMessage` when it has finished running all the tools it needs to run, you can do so by checking the last message and returning the agent if it is a `ToolCallSummaryMessage`.\n\n## Custom Candidate Function\n\nOne more possible requirement might be to automatically select the next speaker from a filtered list of agents. For this, we can set `candidate_func` parameter with a custom candidate function to filter down the list of potential agents for speaker selection for each turn of groupchat.\n\nThis allow us to restrict speaker selection to a specific set of agents after a given agent.\n\n> **Note**: The `candidate_func` is only valid if `selector_func` is not set. Returning `None` or an empty list `[]` from the custom candidate function will raise a `ValueError`.\n\n```python\ndef candidate_func(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> List[str]:\n    # keep planning_agent first one to plan out the tasks\n    if messages[-1].source == \"user\":\n        return [planning_agent.name]\n\n    # if previous agent is planning_agent and if it explicitely asks for web_search_agent\n    # or data_analyst_agent or both (in-case of re-planning or re-assignment of tasks)\n    # then return those specific agents\n    last_message = messages[-1]\n    if last_message.source == planning_agent.name:\n        participants = []\n        if web_search_agent.name in last_message.to_text():\n            participants.append(web_search_agent.name)\n        if data_analyst_agent.name in last_message.to_text():\n            participants.append(data_analyst_agent.name)\n        if participants:\n            return participants  # SelectorGroupChat will select from the remaining two agents.\n\n    # we can assume that the task is finished once the web_search_agent\n    # and data_analyst_agent have took their turns, thus we send\n    # in planning_agent to terminate the chat\n    previous_set_of_agents = set(message.source for message in messages)\n    if web_search_agent.name in previous_set_of_agents and data_analyst_agent.name in previous_set_of_agents:\n        return [planning_agent.name]\n\n    # if no-conditions are met then return all the agents\n    return [planning_agent.name, web_search_agent.name, data_analyst_agent.name]\n\n\n# Reset the previous team and run the chat again with the selector function.\nawait team.reset()\nteam = SelectorGroupChat(\n    [planning_agent, web_search_agent, data_analyst_agent],\n    model_client=model_client,\n    termination_condition=termination,\n    candidate_func=candidate_func,\n)\n\nawait Console(team.run_stream(task=task))\n```\n\nYou can see from the conversation log that the Planning Agent returns to conversation once the Web Search Agent and Data Analyst Agent took their turns and it finds that the task was not finished as expected so it called the WebSearchAgent again to get rebound values and then called DataAnalysetAgent to get the percentage change.\n\n## User Feedback\n\nWe can add `UserProxyAgent` to the team to provide user feedback during a run. See [Human-in-the-Loop](./human-in-the-loop.md) for more details about `UserProxyAgent`.\n\nTo use the `UserProxyAgent` in the web search example, we simply add it to the team and update the selector function to always check for user feedback after the planning agent speaks. If the user responds with \"APPROVE\", the conversation continues, otherwise, the planning agent tries again, until the user approves.\n\n```python\nuser_proxy_agent = UserProxyAgent(\"UserProxyAgent\", description=\"A proxy for the user to approve or disapprove tasks.\")\n\n\ndef selector_func_with_user_proxy(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> str | None:\n    if messages[-1].source != planning_agent.name and messages[-1].source != user_proxy_agent.name:\n        # Planning agent should be the first to engage when given a new task, or check progress.\n        return planning_agent.name\n    if messages[-1].source == planning_agent.name:\n        if messages[-2].source\n######################\noutput:", "role": "user"}], "parameters": {"model": "gpt-4o", "frequency_penalty": 0.0, "max_tokens": null, "n": 1, "presence_penalty": 0.0, "temperature": 0.0, "top_p": 1.0}}, "key": "chat_5711c20d9a1037a91a579a7d303df7d4cac7bf5ba9e58b9e5595cac41dc983fe_v2"}